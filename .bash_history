./resize 4 small.bmp larger.bmp
make resize
./resize 4 small.bmp larger.bmp
./resize 4 small.bmp larger.bmp
make resize
./resize 4 small.bmp larger.bmp
make resize
./resize 4 small.bmp larger.bmp
make resize
./resize 4 small.bmp larger.bmp
make resize
./resize 4 small.bmp larger.bmp
make resize
./resize 4 small.bmp larger.bmp
make resize
make resize
make resize
./resize 4 small.bmp larger.bmp
./resize 4 small.bmp larger.bmp
make resize
./resize 4 small.bmp larger.bmp
./resize 4 small.bmp larger.bmp
./resize 4 small.bmp larger.bmp
make resize
./resize 4 small.bmp larger.bmp
./resize 4 small.bmp larger.bmp
./resize 4 small.bmp larger.bmp
make resize
./resize 4 small.bmp larger.bmp
make resize
./resize 4 small.bmp larger.bmp
make resize
./resize 4 small.bmp larger.bmp
make resize
./resize 4 small.bmp larger.bmp
./resize 4 small.bmp larger.bmp
make resize
./resize 4 small.bmp larger.bmp
make resize
./resize 4 small.bmp larger.bmp
./resize 4 small.bmp larger.bmp
make resize
./resize 4 small.bmp larger.bmp
make resize
./resize 4 small.bmp larger.bmp
make resize
./resize 4 small.bmp larger.bmp
make resize
./resize 4 small.bmp larger.bmp
./resize  small.bmp larger.bmp
./resize 6 small.bmp larger.bmp
./resize 6 small.bmp larger.bmp
debug50 resize.c
./resize 4 small.bmp large.bmp
style50 resize.c
style50 resize.c
check50 cs50/problems/2019/x/resize/less
submit50 cs50/problems/2019/x/resize/less
cd ..
mkdir more
cd more
wget https://cdn.cs50.net/2018/fall/psets/3/resize/more/resize.zip
unzip resize.zip
cp copy.c resize.c
make resize
make resize
make resize
./resize .5 large.bmp smaller.bmp
./resize .9 large.bmp smaller.bmp
./resize .9 large.bmp smaller.bmp
./resize 1 large.bmp smaller.bmp
make resize
cd more
make resize
make resize
./resize .5 large.bmp smaller.bmp
make resize
./resize .5 large.bmp smaller.bmp
make resize
./resize .5 large.bmp smaller.bmp
make resize
./resize .5 large.bmp smaller.bmp
./resize .5 large.bmp smaller.bmp
make resize
./resize .5 large.bmp smaller.bmp
cp copy.c resize.c
make resize
cp copy.c resize.c
make resize
make resize
make resize
make resize
./resize .5 large.bmp smaller.bmp
./resize .5 large.bmp smaller.bmp
make resize
./resize .5 large.bmp smaller.bmp
./resize 0.5 large.bmp smaller.bmp
make resize
./resize .5 large.bmp smaller.bm[2p
./resize 0.5 large.bmp smaller.bmp
check50 resize,c
check50 resize.c
check50 resize
check50 cs50/problems/2019/x/resize/more
make resize
./resize 0.5 large.bmp smaller.bmp
check50 cs50/problems/2019/x/resize/more
check50 cs50/problems/2019/x/resize/more
make resize
make resize
./resize 2 small.bmp large.bmp
make resize
make resize
check50 cs50/problems/2019/x/resize/more
check50 cs50/problems/2019/x/resize/more
style50 resize.c
style50 resize.c
make resize
check50 cs50/problems/2019/x/resize/more
./resize .5 large.bmp smaller.bmp
check50 cs50/problems/2019/x/resize/more
make resize
check50 cs50/problems/2019/x/resize/more
make resize
check50 cs50/problems/2019/x/resize/more
make resize
./resize 4 small.bmp student.bmp
./resize 6 small.bmp student.bmp
cp resize.c copyrs.c
make resize
./resize 6 small.bmp student.bmp
make resize
./resize 9 small.bmp student.bmp
cd
cd pset3
mkdir recover
cd recover
wget https://cdn.cs50.net/2018/fall/psets/3/recover/recover.zip
unzip recover.zip
unzip recover.zip
unzip recover.zip
cd
cd
cd
cd pset3
cd recover
make recover
make recover
make recover
make recover
make recover
make recover
make recover
make recover
make recover
make recover
make recover
make recover
make recover
make recover
make recover
make recover
make recovermake
make recover
make recover
make recover
make recover
make recover
make recover
make recover
make recover
make recover
make recover
make recover
make recover
make recover
cd recover
cd
cd pset3/recover
make recover
make recover
make recover
make recover
make recover
./recover card.raw
./recover card.raw
make recover
make recover
./recover card.raw
make recover
make recover
./recover card.raw
make recover
./recover card.raw
make recover
./recover card.raw
./recover card.raw
make recover
./recover card.raw
make recover
make recover
./recover card.raw
make recover
make recover
./recover card.raw
make recover
make recover
make recover
make recover
./recover card.raw
make recover
./recover card.raw
cd
cd pset3/recover
make recover
./recover card.raw
make recover
./recover card re
make recover
./recover card re
lls
ls
debug50
debug50 ./recover
debug50 recover.c
debug50 recover
debug50 recover
debug50 recover.c
debug50 ./recover
debug50
debug50 cs50/problems/2019/x/recover
debug50 recover
make recover
debug50 recover
debug50 recover
debug50 recover
debug50 recover
make recover
debug50 recover
make recover
debug50 ./recover
debug50 ./recover card.raw
make recover
debug50 ./recover card.raw
make recover
debug50 ./recover card.raw
make recover
debug50 ./recover card.raw
debug50 ./recover card.raw
make recover
debug50 ./recover card.raw
make recover
make recover
make recover
debug50 ./recover card.raw
make recover
debug50 ./recover card.raw
debug50 ./recover card.raw
debug50 ./recover card.raw
make recover
debug50 ./recover card.raw
make recover
debug50 ./recover card.raw
make recover
debug50 ./recover card.raw
make recover
./recover card.raw
echo $?
make recover
make recover
make recover
echo $?
./recover card.raw
./recover card.raw
echo $?
make recover
./recover card.raw
echo $?
make recover
make recover
./recover card.raw
make recover
make recover
./recover card.raw
make recover
./recover card.raw
check50
check50 cs50/problems/2019/x/recover
check50 cs50/problems/2019/x/recover
make recover
./recover card.raw
make recover
./recover card.raw
make recover
./recover card.raw
make recover
make recover
make recover
./recover card.raw
make recover
./recover card.raw
make recover
make recover
make recover
./recover card.raw
rm -f *.jpg
make recover
./recover card.raw
rm -f *.jpg
make recover
./recover card.raw
make recover
./recover card.raw
./recover card.raw
./recover card.raw
make recover
./recover card.raw
make recover
./recover card.raw
make recover
make recover
./recover card.raw
rm -f *.jpg
make recover
make recover
./recover card.raw
rm -f *.jpg
make recover
./recover card.raw
make recover
./recover card.raw
make recover
make recover
make recover
./recover card.raw
rm -f *.jpg
make recover
rm -f *.jpg
make recover
./recover card.raw
make recover
make recover
./recover card.raw
rm -f *.jpg
make recover
rm -f *.jpg
make recover
make recover
rm -f *.jpg
./recover card.raw
make recover
./recover card.raw
rm -f *.jpg
make recover
./recover card.raw
make recover
./recover card.raw
check50 check50 cs50/problems/2019/x/recover
ceck50 check50 cs50/problems/2019/x/recover
check50 cs50/problems/2019/x/recover
#include <stdio.h>submit50
#include <stdlib.h>
#include <stdint.h>
int main(int argc, char *argv[])
{     // ./recover card.raw;     if(argc != 2);     {         printf("Usage: ./recover image\n");
        return 1;
    }
    FILE *file = fopen(argv[1], "r"); //reading the file
    int count = 0;
    uint8_t buffer[512];
    char filename[512];
    int bytenum = 1;
    int found = 0;
    int c = 0;
    /*
    while (fread(buffer, 512, 1, file))
        {             if (buffer[0] == 0xff &&             buffer[1] == 0xd8 &&             buffer[2] == 0xff &&             (buffer[3] & 0xf0) == 0xe0)
            {                 printf("sig found %i\n", c++);
            }
        }
        */
    while (fread (buffer, 512, 1, file))
    {         if ((buffer[0]) == 0xff &&
            (buffer[1]) == 0xd8 &&
            (buffer[2]) == 0xff &&
            ((buffer[3]) & 0xf0) == 0xe0) // then we found a JPEG
        {             found = 1;             break;         }
    }
    // int bytenum = fread (buffer, 512, 1, file);
     while (1);         {         if ((buffer[0]) == 0xff &&
            (buffer[1]) == 0xd8 &&
            (buffer[2]) == 0xff &&
            ((buffer[3]) & 0xf0) == 0xe0) // then we found a JPEG
        {             found = 1;             sprintf (filename, "%03i.jpg", count++);
            //1st make an array (pointer) for the file to deal
            //2nd a real filename, 3rd the number of it
        }
        //else if (found == 0) continue;
        FILE *img = fopen(filename, "w");
        fwrite (buffer, 512, 1, img);
        bytenum = fread (buffer, 512, 1, file);
        while(((buffer[0]) == 0xff &&               (buffer[1]) == 0xd8 &&               (buffer[2]) == 0xff &&               ((buffer[3]) & 0xf0) == 0xe0) == 0)
              {                   fwrite (buffer, 512, 1, img);
                  bytenum = fread (buffer, 512, 1, file);
                  if(bytenum == 0) return 0;
              }
        /*else
        {                 FILE *img = fopen(filename, "w");
                fwrite (buffer, 512, 1, img);
                //fclose(img);
        }*/
    }
    fclose(file);
    return 0;
}
check50 cs50/problems/2019/x/recover
make recover
check50 cs50/problems/2019/x/recover
make recover
check50 cs50/problems/2019/x/recover
         
    Staffâ€™s Solution
    Hints
    How to Submit
Recover
tl;dr
Implement a program that recovers JPEGs from a forensic image, per the below.
$ ./recover card.raw
Introduction
Background
Even though JPEGs are more complicated than BMPs, JPEGs have "signatures," patterns of bytes that can distinguish them from other file formats. Specifically, the first three bytes of JPEGs are
0xff 0xd8 0xff
from first byte to third byte, left to right. The fourth byte, meanwhile, is either 0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, or 0xef. Put another way, the fourth byteâ€™s first four bits are 1110.
Odds are, if you find this pattern of four bytes on media known to store photos (e.g., my memory card), they demarcate the start of a JPEG. To be fair, you might encounter these patterns on some disk purely by chance, so data recovery isnâ€™t an exact science.
Fortunately, digital cameras tend to store photographs contiguously on memory cards, whereby each photo is stored immediately after the previously taken photo. Accordingly, the start of a JPEG usually demarks the end of another. However, digital cameras often initialize cards with a FAT file system whose "block size" is 512 bytes (B). The implication is that these cameras only write to those cards in units of 512 B. A photo thatâ€™s 1 MB (i.e., 1,048,576 B) thus takes up 1048576 Ã· 512 = 2048 "blocks" on a memory card. But so does a photo thatâ€™s, say, one byte smaller (i.e., 1,048,575 B)! The wasted space on disk is called "slack space." Forensic investigators often look at slack space for remnants of suspicious data.
The implication of all these details is that you, the investigator, can probably write a program that iterates over a copy of my memory card, looking for JPEGs' signatures. Each time you find a signature, you can open a new file for writing and start filling that file with bytes from my memory card, closing that file only once you encounter another signature. Moreover, rather than read my memory cardâ€™s bytes one at a time, you can read 512 of them at a time into a buffer for efficiencyâ€™s sake. Thanks to FAT, you can trust that JPEGs' signatures will be "block-aligned." That is, you need only look for those signatures in a blockâ€™s first four bytes.
Realize, of course, that JPEGs can span contiguous blocks. Otherwise, no JPEG could be larger than 512 B. But the last byte of a JPEG might not fall at the very end of a block. Recall the possibility of slack space. But not to worry. Because this memory card was brand-new when I started snapping photos, odds are itâ€™d been "zeroed" (i.e., filled with 0s) by the manufacturer, in which case any slack space will be filled with 0s. Itâ€™s okay if those trailing 0s end up in the JPEGs you recover; they should still be viewable.
Now, I only have one memory card, but there are a lot of you! And so Iâ€™ve gone ahead and created a "forensic image" of the card, storing its contents, byte after byte, in a file called card.raw. So that you donâ€™t waste time iterating over millions of 0s unnecessarily, Iâ€™ve only imaged the first few megabytes of the memory card. But you should ultimately find that the image contains 50 JPEGs.
Getting Started
Hereâ€™s how to download this problemâ€™s "distribution code" (i.e., starter code) into your own CS50 IDE. Log into CS50 IDE and then, in a terminal window, execute each of the below.
    Execute cd to ensure that youâ€™re in ~/ (aka your home folder).
    Execute mkdir pset3 to make (i.e., create) a directory called pset3 in your home directory.
    Execute cd pset3 to change into (i.e., open) that directory.
    Execute wget https://cdn.cs50.net/2018/fall/psets/3/recover/recover.zip to download a (compressed) ZIP file with this problemâ€™s distribution.
    Execute unzip recover.zip to uncompress that file.
    Execute rm recover.zip followed by yes or y to delete that ZIP file.
    Execute ls. You should see a directory called recover, which was inside of that ZIP file.
    Execute cd recover to change into that directory.
    Execute ls. You should see this problemâ€™s distribution, including card.raw and recover.c.
Specification
Implement a program called recover that recovers JPEGs from a forensic image.
    Implement your program in a file called recover.c in a directory called recover.
    Your program should accept exactly one command-line argument, the name of a forensic image from which to recover JPEGs. + If your program is not executed with exactly one command-line argument, it should remind the user of correct usage, as with fprintf (to stderr), and main should return 1.
    If the forensic image cannot be opened for reading, your program should inform the user as much, as with fprintf (to stderr), and main should return 2.
    Your program, if it uses malloc, must not leak any memory.
Walkthrough
Usage
Your program should behave per the examples below. Assumed that the underlined text is what some user has typed.
$ ./recover
Usage: ./recover image
$ echo $?
1
$ ./recover card.raw
$ echo $?
0
Testing
check50
Hereâ€™s how to evaluate the correctness of your code using check50. But be sure to compile and test it yourself as well!
check50 cs50/problems/2019/x/recover
style50
Hereâ€™s how to evaluate the style of your code using style50.
style50 recover.c
style50 recover.c
style50 recover.c
style50 recover.c
style50 recover.c
style50 recover.c
make recover
check50 cs50/problems/2019/x/recover
submit50 cs50/problems/2019/x/recover
cd
cd pset3
cd resize/more
submit50 cs50/problems/2019/x/resize/more
submit50 cs50/problems/2019/x/resize/more
check50 cs50/problems/2019/x/resize/more
cd
cd pset3
mkdir plurality
cd plurality
wget https://cdn.cs50.net/2019/fall/psets/3/plurality/plurality.c
check50 cs50/problems/2020/x/plurality
style50 plurality.c
submit50 cs50/problems/2020/x/plurality
cd
cd pset3
mkdir runoff
cd runoff
wget https://cdn.cs50.net/2019/fall/psets/3/runoff/runoff.c
ls
cd pset3
cd
cd pset3
cd runoff
make runoff
make runoff
make runoff
make runoff
check50 cs50/problems/2020/x/runoff
re tied
check50 cs50/problems/2020/x/runoff
check50 cs50/problems/2020/x/runoff
check50 cs50/problems/2020/x/runoff
check50 cs50/problems/2020/x/runoff
check50 cs50/problems/2020/x/runoff
style50 runoff.c
submit50 cs50/problems/2020/x/runoff
cd
mkdir pset4
wget https://cdn.cs50.net/2019/fall/psets/4/recover/recover.zip
